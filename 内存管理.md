# 内存管理

## 内存的基础知识

### 内存地址

逻辑地址：**相对地址**

物理地址：在硬件上的**绝对地址**

### 从编辑程序到运行

编译-链接-装入

编译：源代码-目标模块

链接：目标模块-装入模块，连接后形成完整的逻辑地址

装入：将装入模块装入内存，转个后形成物理地址

### 装入的三种方式

绝对装入：产生**绝对地址**的目标代码，把装入模块直接存入对应的内存中

**静态重定位**：（可重定位装入）编译、链接后的装入模块的地址都是从0开始的，此时为逻辑地址，在装入的一瞬间，对地址进行重定位，将逻辑地址转化为物理地址（**在装入时一次性完成**）

**动态重定位**：（动态运行时装入）将装入模块装入内存后，先不转换，等程序真正要执行的时候才进行地址转换，需要**重定位寄存器**的支持

### 链接的三种方式

静态链接

装入时动态链接

运行时动态链接

## 内存分配管理

### 连续分配管理

单一连续分配：有内部碎片，只支持单道程序（用不上）

![image-20210926204412264](/Users/yangliwei/Library/Application Support/typora-user-images/image-20210926204412264.png)

固定分区分配：有内部碎片，分区大小可以相等，可以不等，一个分区只能运行一道进程，随意根据进程的大小可能会产生内部碎片（分区用不完）。

动态分区分配：有外部碎片，在进程装入内存的时候，根据进程大小动态建立分区。比如说1-20区我们用了，那下一个程序就是20区开始用，这个时候呢，进程1结束了，1-20区空出来了，再进来了一个占19个区域的进程，那就回空出一个区域出来，基本上这个区域是跑不了程序的，就成了外部碎片。

解决方法：建立空闲分区表或者空闲分区链及时调整

动态分区分配算法的基本概念

![image-20210926205301750](/Users/yangliwei/Library/Application Support/typora-user-images/image-20210926205301750.png)

### 基本分页存储管理

基本思路：

​	把内存空间分为一个个大小相等的分区，每个分区叫做页框或者页帧、内存块，且他们都有独立的编号，类似页帧号这样。

​	把进程也分成和页帧大小相等的区域，叫做页或者页面

​	然后一一对应塞进去，nice

**计算题：**

- **页号 = 逻辑地址/页面大小** 从0开始计算，计算时向下取整即可
  - 比如：2500/1024 =2 ，在第2页里面，前面还有0页和1页

- **页内偏移量 = 逻辑地址%页面大小**
- 逻辑地址 = [页号p，页内偏移量w] （集合形式）

页表：

- 记录进程页面和实际存放的内存块之间的对应关系

- 一个进程对应一张页表，进程的每一页对应一个页表项：由页号和块号组成
- 页表项长度相同，页号是隐含的

### 基本地址变换机构

页表寄存器PTR：

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址

- 寄存页表在内存中的起始地址F和长度M
- 未执行的时候，F和M在PCB（进程控制块）中，当进程被调度时，操作系统内核会把他们放在页表寄存器里。
- 计算方法
  - 根据逻辑地址计算出页号和页内偏移量
  - 判断页号是否越界，越界则中断
  - 查询页表，找到页号对应的页表项，确定内存块号
  - 用内存块号和页内偏移量得到物理地址
  - 物理地址 = b（内存块号）* L(页面大小)+W（页偏移*量）
  - 根据物理地址访问目标存储单元
- 页表长度：也表中有几个页表项
- 页表项长度：这个页表项占多大空间
- 业内偏移量的位数，有n位一位置一个页面的大小是2的n次方B，占10位就是2的10次方约等于1KB

### 快表 联想寄存器

时间局部性：存在大量循环的情况下，程序很可能多次重复访问某个存储单元

空间局部性：程序访问某个存储单元后，很可能会紧接着访问其附近的存储单元

**快表**：联想寄存器，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。普通页表一般称之为***慢表***

工作原理：最近使用过的页表项会放入快表，程序访问的时候先找快表，快表未命中再去访问内存中的页表（慢表）

### 两级页表

单级页表的缺点：

- 需要连续存放，当页表很大时会占用很多个连续的页框
- 没有必要让整个页表常驻内存，因为进程在一段时间内很可能只需要访问某几个特定的页面

实现原理：说白了就是把在本来的页表的基础上再加一个索引，也就是一维变二维。![image-20210927150812486](/Users/yangliwei/Library/Application Support/typora-user-images/image-20210927150812486.png)

 ### 基本分段存储管理

与分页最大区别在于“离散分配时所分配地址空间的基本单位不同”

进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每段都有一个段名，且从0开始编址。（由于是按照逻辑功能划粉，用户编程会更方便，程序的可读性会更高）

*段号的位数决定了每个进程最多可以分成几段*

*段内地址的位数决定了每个段的最大长度是多少*  

![image-20210927160434149](/Users/yangliwei/Library/Application Support/typora-user-images/image-20210927160434149.png)



### 分段和分页的对比

- 页是信息的物理单位，分页是系统行为，仅出于系统管理上的需要，对用户不可见。 

- 段是信息的逻辑单位，分段的目的是为了更好的满足用户需求，对用户是可见的。
- 页的大小固定且由系统决定，段的长度不固定，取决于用户编写的程序。
- 分页的用户进程地址空间是一维的，分段则是二维滴！
- 分段优点：更容易实现信息的**共享和保护**

![image-20210927161232812](/Users/yangliwei/Library/Application Support/typora-user-images/image-20210927161232812.png)	

	### 段页式管理方式

![image-20210927161638691](/Users/yangliwei/Library/Application Support/typora-user-images/image-20210927161638691.png)

区别所在：

![image-20210927161846739](/Users/yangliwei/Library/Application Support/typora-user-images/image-20210927161846739.png)

![image-20210927162438639](/Users/yangliwei/Library/Application Support/typora-user-images/image-20210927162438639.png)





