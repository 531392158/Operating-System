## I/O设备

## IO控制方式

### 程序直接控制方式

1.完成以此读写操作的刘成刚（Key word 轮询，见下）

<img src="/Users/yangliwei/Library/Application Support/typora-user-images/image-20211011162942206.png" alt="image-20211011162942206" style="zoom: 33%;" />

2.CPU干预的频率表

很频繁，I/O操作开始之前、完成之后需要CPU的介入，并且在等待完成的过程中不断地进行轮询检查

3.数据传送的单位

每次读写**一个字**

4.数据的流向

输入：设备-cpu-内存

输出：内存-cpu-设备

5.缺点和优点

优点：实现简单，在读写指令只有加上实现循环检查的一系列指令即可

缺点：cpu和i/o设备只能串行工作，且cpu需要一直轮询检查，长期处于忙等的状态，**利用率低**。

### 中断驱动方式

 引入中断机制，由于io设备速度很慢，因此cpu在发出读写命令后，可以将io进程阻塞，先切换到别的进程执行，当io完成后，控制器会向cpu发送一个中断信号，此时的cpu*会保存当前进程的运行环境信息*，先去执行中断处理程序。

相比较**程序直接控制**

- cpu会在每个指令周期的末尾检查中断

- cpu干预的频率降低
- 解决了cpu不断轮询的忙等问题
- 中断处理过程中保存和恢复环境是需要一定时间开销的，倘若中断发生频率太高会降低系统性能。

### DMA方式

改进方式：

- 数据的传输单位是”块“而不是”字“
- 数据的流向是从设备直接放入内存，或者从内存直接到设备，不再需要cpu
- 只有当传送一个或者多个数据块的开始和结束的时候才需要cpu干预。

相比较中断驱动方式：

- CPU干预频率降低
- 传输效率提升cpu和io设备的并行性的到提升
- 缺点：每条指令，只能读写一个或多个连续的数据块，如果是离散的数据，则需要多条指令

### 通道控制方式

通道：一种硬件，可以称作miniCPU。通道可以识别并执行一系列通道指令

 操作方式：

- CPU想通道发出I/O 指令。指明通道程序在内存中的位置以及要操作的是那个I/O 设备，**之后cpu就会切换到其他进程执行**
- 通道执行内存中的通道程序
- 通道执行完规定的任务后，想CPU发出中断信号，之后CPU对中断进行处理

### 总体对比

![image-20211012163810123](/Users/yangliwei/Library/Application Support/typora-user-images/image-20211012163810123.png)

## I/O 软件层次结构

四层软件程序

- 用户层软件
  - 实现与用户交互的接口
- 设备独立性软件
  - 也就是设备无关性软件，与设备的硬件特性无关的功能几乎都在这一层实现
  - 主要实现的功能
    - 向上层提供统一的调用接口
    - 设备保护
    - 差错处理
    - 设备的分配与回收
    - 数据缓冲区管理
    - 建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调动相应的驱动程序 
- 设备驱动程序
  - 不同的设备需要不同的设备驱动程序
  - 主要负责对硬件设备的具体控制，将上层发出的一系列命令转化成特定设备能够识别的一系列操作。包括设置设备寄存器，检查设备状态等。
- 中断处理程序
  - 当I/O 任务完成时，I/O 控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。
- 重点：
  - 记住各个层次的顺序
    - 要能够推断某个处理应该是在哪个层次完成的
    - 常考设备独立性软件和设备驱动程序这两层
  - 直接设计到硬件具体细节、且与中断无关的操作肯定是**设备驱动层**
  - 没有设计硬件的、对各种农设备都需要进行管理的工作都是在设备**独立性软件层**完成的

### 假脱机技术

脱机技术：脱离主机的控制进行输入和输出操作。

假脱机技术：用软件的方式模拟脱机技术

输入进程和输出进程：

![image-20211012171126047](/Users/yangliwei/Library/Application Support/typora-user-images/image-20211012171126047.png)

共享打印机的原理：如果有多个用户申请使用打印机，打印机会先同意所有用户的申请，然后由**假脱机管理进程**为每一个进程在磁盘输出井中申请一个空闲缓冲区，再把信息存储到这个缓冲区中，再依次打印出来。

SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。

### 设备的分配与回收

设备分配时的考虑因素

- 设备的固有属性
  - 独占设备：一时只能分配给一个进程
  - 共享设备：分给多个进程
  - 虚拟设备：用SPOOLing技术改造的共享设备

- 设备分配算法
  - 先来先服务算法等等
- 设备的分配的安全性
  - 安全分配方式：为进程分配一个设备后就将进程阻塞，本次I/O 完成后才将进程唤醒
    - 不会产生死锁，但是效率低
  - 不安全分配方式：进程发出I/O 请求后，系统为其分配I/O 设备，进程可继续执行，之后还可以发出新的I/O 请求。只有某个I/O 请求得不到满足时才进行进程阻塞。

静态分配与动态分配

- 静态分配：进程运行前为其分配全部的所需资源，运行结束后再同意归还资源
- 动态分配：在运行的过程中动态分配资源

设备分配管理中的数据结构

- 一个通道可以控制多个设备控制器，每个设备控制器可控制多个设备
- 设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况
- 控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理
- 通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理
- 系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目。

== 设备分配的步骤 ==

1.根据进程请求的物理设备名查找SDT。

2.根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。

3.根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。

4.根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。

缺点：

- 用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程
- 若换了一个物理设备，则程序无法运行
- 若进程请求的物理设备正在忙碌，则及时系统中还有同类型的设备，进程也必须阻塞等待。 

== **设备分配步骤的改进** ==（逻辑设备表）

1.根据进程请求的逻辑设备名查找SDT

2.查找SDT，找到用户进程制定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表中新增一个表项。

3.后面跟上面3和4一样

### 缓冲区管理

单缓冲：假设某用户进程秦秋某种块设备读入若干块的互数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区。

（当缓冲区数据为费控）

